<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cost Savings on Max Woolf&#39;s Blog</title><link>/categories/cost-savings/</link><description>Recent content in Cost Savings on Max Woolf&#39;s Blog</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Copyright Max Woolf &amp;copy; {year}</copyright><lastBuildDate>Mon, 19 Nov 2018 09:00:00 +0000</lastBuildDate><atom:link href="/categories/cost-savings/index.xml" rel="self" type="application/rss+xml"/><item><title>Run Any Scheduled Task/Cron Super-Cheap on Google Cloud Platform</title><link>/2018/11/cheap-cron/</link><pubDate>Mon, 19 Nov 2018 09:00:00 +0000</pubDate><guid>/2018/11/cheap-cron/</guid><description>
&lt;p&gt;Let&amp;rsquo;s say you want to make a &lt;a href=&#34;https://twitter.com&#34; target=&#34;_blank&#34;&gt;Twitter&lt;/a&gt; bot to tweet out a custom message every few hours or so, and the free-tier VMs offered by cloud services with fractional virtual CPUs and little RAM aren&amp;rsquo;t sufficient. How do you host the bot? Many suggest you get a &lt;a href=&#34;https://www.digitalocean.com&#34; target=&#34;_blank&#34;&gt;Digital Ocean&lt;/a&gt; VM for &lt;a href=&#34;https://www.digitalocean.com/pricing/&#34; target=&#34;_blank&#34;&gt;$5/mo&lt;/a&gt;, which is not a bad price. But what if you want to run &lt;em&gt;multiple&lt;/em&gt; bots? How do you easily coordinate multiple scheduled tasks?&lt;/p&gt;
&lt;p&gt;In my case, I maintain three bots: a bot which &lt;a href=&#34;https://twitter.com/MTGIFening&#34; target=&#34;_blank&#34;&gt;tweets GIFs&lt;/a&gt; superimposed onto Magic: The Gathering cards, a bot which &lt;a href=&#34;https://twitter.com/hackernews_nn&#34; target=&#34;_blank&#34;&gt;tweets AI-generated Hacker News submission titles&lt;/a&gt;, and a bot which makes &lt;a href=&#34;https://www.reddit.com/r/subredditnn&#34; target=&#34;_blank&#34;&gt;AI-generated Reddit submissions&lt;/a&gt;. I found a clever solution to the multiple-bots problem: leveraging &lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/how-to/cronjobs&#34; target=&#34;_blank&#34;&gt;CronJobs&lt;/a&gt; with &lt;a href=&#34;https://cloud.google.com/kubernetes-engine/&#34; target=&#34;_blank&#34;&gt;Google Kubernetes Engine&lt;/a&gt; + a single worker node. Each bot has its own CronJob which tells when GKE should schedule a Job for each task, and then the cluster executes the Jobs whenever compute capacity is available (i.e. no resource hogging/race conditions), and can ensure completion by restarting the task if it fails.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/cheap-cron/kubecron.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The cost of running a cluster in GKE is just the cost of the compute: using a preemptible n1-standard-1 (1 vCPU/3.75 GB RAM) worker node VM, the &lt;a href=&#34;https://cloud.google.com/compute/pricing&#34; target=&#34;_blank&#34;&gt;cost&lt;/a&gt; is about &lt;strong&gt;$7.30/mo&lt;/strong&gt;, a bit more than the Digital Ocean server but can theoretically handle an unlimited number of scheduled tasks. The problem is the worker node needs to be up &lt;sup&gt;24&lt;/sup&gt;&amp;frasl;&lt;sub&gt;7&lt;/sub&gt; even though the bots run sporadically.&lt;/p&gt;
&lt;p&gt;But thanks to a few new synergies within GCP products, it&amp;rsquo;s possible to get the cost of running a scheduled task down to &lt;em&gt;less than a dollar a month&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;gcp-shenanigans&#34;&gt;GCP Shenanigans&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/blog/products/application-development/announcing-cloud-scheduler-a-modern-managed-cron-service-for-automated-batch-jobs&#34; target=&#34;_blank&#34;&gt;A couple weeks ago&lt;/a&gt;, Google released &lt;a href=&#34;https://cloud.google.com/scheduler/&#34; target=&#34;_blank&#34;&gt;Cloud Scheduler&lt;/a&gt;, which is a managed cron service that can perform tasks for other Google services. With that launch, Google also released a tutorial titled &lt;a href=&#34;https://cloud.google.com/scheduler/docs/scheduling-instances-with-cloud-scheduler&#34; target=&#34;_blank&#34;&gt;Scheduling Instances with Cloud Scheduler&lt;/a&gt;, demonstrating how you can programmatically start and stop instances using Cloud Scheduler in conjunction with &lt;a href=&#34;https://cloud.google.com/functions/&#34; target=&#34;_blank&#34;&gt;Cloud Functions&lt;/a&gt;. The demo use case is to schedule VMs during business hours, which gave me an idea; could this approach be used to boot up a VM, run a script, and then shut it down to minimize uptime?&lt;/p&gt;
&lt;p&gt;I followed the tutorial instructions, which contains code to create a Cloud Function which boots up a specified VM, code for a Cloud Function to shut down a specified VM, and how to create cron jobs in Cloud Scheduler to invoke those two Functions at a specified time. For my scheduled tasks, I only need the instance up for a couple minutes: for example we can use a Cloud Scheduler job to start an instance every 4 hours at X:00 with the cron &lt;code&gt;0 */4 * * *&lt;/code&gt;, and shut it down 2 minutes later at X:02 with the cron &lt;code&gt;2 */4 * * *&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The next step is configuring a Google Compute Engine VM to run the scheduled task on boot. There are two ways to go about it: one is to use the &lt;code&gt;startup-script&lt;/code&gt; field when configuring a VM, which specifies a command to run on boot and gets the job done. Another approach (which I use) is to package the scheduled task as a &lt;a href=&#34;https://www.docker.com/resources/what-container&#34; target=&#34;_blank&#34;&gt;Docker Container&lt;/a&gt;, and use a container-optimized OS which simply runs a specified container upon boot (although you should set restart to &lt;code&gt;On Failure&lt;/code&gt; and give &lt;code&gt;Privileged Access&lt;/code&gt; to the container). Additionally, the VM can be configured as a preemptible instance for massive cost savings, as the &amp;ldquo;shut-down-at-anytime&amp;rdquo; constraint is irrelevant for this use case!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/cheap-cron/vm.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;After the VMs are created, I created the start/stop tasks targeting those VMs as noted in the tutorial.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/cheap-cron/scheduler.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;I can verify that this workflow indeed works for all my bots, and the crons have been running successfully at the specified time, for only a couple minutes!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/cheap-cron/working.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;crunching-the-numbers&#34;&gt;Crunching the Numbers&lt;/h2&gt;
&lt;p&gt;This approach incorporates many different Google products. Is it &lt;em&gt;actually&lt;/em&gt; cheaper than just maintaining a simple $5/month server? Let&amp;rsquo;s calculate the monthly cost of all these services.&lt;/p&gt;
&lt;p&gt;Assuming that we run a scheduled task every 4 hours, and the server is up for 2 minutes each time (i.e. 12 minutes of uptime a day):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Compute Engine&lt;/strong&gt;: A preemptible n1-standard-1 is &lt;a href=&#34;https://cloud.google.com/compute/pricing&#34; target=&#34;_blank&#34;&gt;$0.01 an hour&lt;/a&gt;. &lt;code&gt;$0.01 / 60 * 12 * 30 = $0.06&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VM Persistent Disk&lt;/strong&gt;: Each GB of storage for a VM costs &lt;a href=&#34;https://cloud.google.com/compute/pricing#disk&#34; target=&#34;_blank&#34;&gt;$0.04/month&lt;/a&gt;, and the minimum storage size is 10GB. &lt;code&gt;$0.04 * 10 = $0.40&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud Scheduler&lt;/strong&gt;: Each rule is &lt;a href=&#34;https://cloud.google.com/scheduler/pricing&#34; target=&#34;_blank&#34;&gt;$0.10/month&lt;/a&gt;, and there are both a start and a stop rule. &lt;code&gt;$0.10 * 2 = $0.20&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud Functions&lt;/strong&gt;: It takes about 60 seconds total to turn on and off a VM, and with the default 256MB provision, during which it costs &lt;a href=&#34;https://cloud.google.com/functions/pricing&#34; target=&#34;_blank&#34;&gt;$.000000463/100ms&lt;/a&gt;. &lt;code&gt;0.000000463 * 10 * 60 * 12 * 30 = $0.10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$0.06 + $0.40 + $0.20 + $0.10 = &lt;strong&gt;$0.76/month to run the scheduled task&lt;/strong&gt;! That&amp;rsquo;s not even counting the free tier bonuses if you just want to create one scheduled task; in that case, the only price you pay is the $0.06/mo for the VM. And even in the case where you run the task every hour (like in the images above), the cost is $1.24/month; still not bad.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s worth noting that these pricing economics wouldn&amp;rsquo;t have worked years ago. Back then &lt;a href=&#34;https://aws.amazon.com&#34; target=&#34;_blank&#34;&gt;Amazon Web Services&lt;/a&gt;, the leader in web services, charged for a minimum of 1 hour every time a VM was booted. Google Compute Engine innovated by only requiring a minimum of 10 minutes, which is much better but still would have had unnecessary overhead (in this example, it would increase compute monthly costs by $0.&lt;sup&gt;24&lt;/sup&gt;&amp;frasl;&lt;sub&gt;31&lt;/sub&gt;%). &lt;a href=&#34;https://cloud.google.com/blog/products/gcp/extending-per-second-billing-in-google&#34; target=&#34;_blank&#34;&gt;As of September 2017&lt;/a&gt;, Google Compute Engine charges a minimum of &lt;strong&gt;1 minute&lt;/strong&gt;, which makes this workflow possible and cheap (AWS made the same change &lt;a href=&#34;https://aws.amazon.com/blogs/aws/new-per-second-billing-for-ec2-instances-and-ebs-volumes/&#34; target=&#34;_blank&#34;&gt;a week earlier&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s also possible that similar workflows exist for AWS and &lt;a href=&#34;https://azure.microsoft.com/en-us/&#34; target=&#34;_blank&#34;&gt;Azure Cloud&lt;/a&gt;, although I&amp;rsquo;m less familiar with those platforms (and it may not necessarily be better/cheaper). Sure, if you have a very simple task to practice making bots in the cloud, the free tier of any cloud service might suffice (where you run the server all the time, and schedule the cron on the server itself). If you&amp;rsquo;re planning many scheduled tasks, then a centralized approach like my initial Kubernetes implementation might actually be more cost effective. But if you&amp;rsquo;re somewhere &lt;em&gt;in between&lt;/em&gt;, then giving each scheduled task its own VM makes more sense for both ease of use and cost-effectiveness. And there&amp;rsquo;s still many further optimizations to be done too (for example, by allowing the script in the VM to ping a HTTP Cloud Function endpoint and shut &lt;em&gt;itself&lt;/em&gt; off when complete instead of using a scheduled cron rule).&lt;/p&gt;</description></item><item><title>Benchmarking Modern GPUs for Maximum Cloud Cost Efficiency in Deep Learning</title><link>/2017/11/benchmark-gpus/</link><pubDate>Tue, 28 Nov 2017 08:30:00 +0000</pubDate><guid>/2017/11/benchmark-gpus/</guid><description>
&lt;p&gt;A few months ago, I &lt;a href=&#34;http://minimaxir.com/2017/06/keras-cntk/&#34; target=&#34;_blank&#34;&gt;performed benchmarks&lt;/a&gt; of deep learning frameworks in the cloud, with a &lt;a href=&#34;http://minimaxir.com/2017/07/cpu-or-gpu/&#34; target=&#34;_blank&#34;&gt;followup&lt;/a&gt; focusing on the cost difference between using GPUs and CPUs. And just a few months later, the landscape has changed, with significant updates to the low-level &lt;a href=&#34;https://developer.nvidia.com/cudnn&#34; target=&#34;_blank&#34;&gt;NVIDIA cuDNN&lt;/a&gt; library which powers the raw learning on the GPU, the &lt;a href=&#34;https://www.tensorflow.org&#34; target=&#34;_blank&#34;&gt;TensorFlow&lt;/a&gt; and &lt;a href=&#34;https://github.com/Microsoft/CNTK&#34; target=&#34;_blank&#34;&gt;CNTK&lt;/a&gt; deep learning frameworks, and the higher-level &lt;a href=&#34;https://github.com/fchollet/keras&#34; target=&#34;_blank&#34;&gt;Keras&lt;/a&gt; framework which uses TensorFlow/CNTK as backends for easy deep learning model training.&lt;/p&gt;
&lt;p&gt;As a bonus to the framework updates, Google &lt;a href=&#34;https://cloudplatform.googleblog.com/2017/09/introducing-faster-GPUs-for-Google-Compute-Engine.html&#34; target=&#34;_blank&#34;&gt;recently released&lt;/a&gt; the newest generation of NVIDIA cloud GPUs, the Pascal-based P100, onto &lt;a href=&#34;https://cloud.google.com/compute/&#34; target=&#34;_blank&#34;&gt;Google Compute Engine&lt;/a&gt; which touts an up-to-10x performance increase to the current K80 GPUs used in cloud computing. As a bonus bonus, Google recently &lt;a href=&#34;https://cloudplatform.googleblog.com/2017/11/new-lower-prices-for-GPUs-and-preemptible-Local-SSDs.html&#34; target=&#34;_blank&#34;&gt;cut the prices&lt;/a&gt; of both K80 and P100 GPU instances by up to 36%.&lt;/p&gt;
&lt;p&gt;The results of my earlier benchmarks favored &lt;a href=&#34;https://cloud.google.com/preemptible-vms/&#34; target=&#34;_blank&#34;&gt;preemptible&lt;/a&gt; instances with many CPUs as the most cost efficient option (where a preemptable instance can only last for up to 24 hours and could end prematurely). A 36% price cut to GPU instances, in addition to the potential new benefits offered by software and GPU updates, however, might be enough to tip the cost-efficiency scales back in favor of GPUs. It&amp;rsquo;s a good idea to rerun the experiment with updated VMs and see what happens.&lt;/p&gt;
&lt;h2 id=&#34;benchmark-setup&#34;&gt;Benchmark Setup&lt;/h2&gt;
&lt;p&gt;As with the original benchmark, I set up a &lt;a href=&#34;https://github.com/minimaxir/keras-cntk-docker&#34; target=&#34;_blank&#34;&gt;Docker container&lt;/a&gt; containing the deep learning frameworks (based on cuDNN 6, the latest version of cuDNN natively supported by the frameworks) that can be used to train each model independently. The &lt;a href=&#34;https://github.com/minimaxir/keras-cntk-benchmark/tree/master/v2/test_files&#34; target=&#34;_blank&#34;&gt;Keras benchmark scripts&lt;/a&gt; run on the containers are based off of &lt;em&gt;real world&lt;/em&gt; use cases of deep learning.&lt;/p&gt;
&lt;p&gt;The 6 hardware/software configurations and Google Compute Engine &lt;a href=&#34;https://cloud.google.com/compute/pricing&#34; target=&#34;_blank&#34;&gt;pricings&lt;/a&gt; for the tests are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A K80 GPU (attached to a &lt;code&gt;n1-standard-1&lt;/code&gt; instance), tested with both TensorFlow (1.4) and CNTK (2.2): &lt;strong&gt;$0.4975 / hour&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;A P100 GPU (attached to a &lt;code&gt;n1-standard-1&lt;/code&gt; instance), tested with both TensorFlow and CNTK: &lt;strong&gt;$1.5075 / hour&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;A preemptable &lt;code&gt;n1-highcpu-32&lt;/code&gt; instance, with 32 vCPUs based on the Intel Skylake architecture, tested with TensorFlow only: &lt;strong&gt;$0.2400 / hour&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A preemptable &lt;code&gt;n1-highcpu-16&lt;/code&gt; instance, with 16 vCPUs based on the Intel Skylake architecture, tested with TensorFlow only: &lt;strong&gt;$0.1200 / hour&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A single K80 GPU uses &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; a GPU board while a single P100 uses a full GPU board, which in an ideal world would suggest that the P100 is twice as fast at the K80 at minimum. But even so, the P100 configuration is about 3 times as expensive, so even if a model is trained in half the time, it may not necessarily be cheaper with the P100.&lt;/p&gt;
&lt;p&gt;Also, the CPU tests use TensorFlow &lt;em&gt;as installed via the recommended method&lt;/em&gt; through pip, since compiling the TensorFlow binary from scratch to take advantage of CPU instructions as &lt;a href=&#34;http://minimaxir.com/2017/07/cpu-or-gpu/&#34; target=&#34;_blank&#34;&gt;with my previous test&lt;/a&gt; is not a pragmatic workflow for casual use.&lt;/p&gt;
&lt;h2 id=&#34;benchmark-results&#34;&gt;Benchmark Results&lt;/h2&gt;
&lt;p&gt;When a fresh-out-of-a-AI-MOOC engineer wants to experiment with deep learning in the cloud, typically they use a K80 + TensorFlow setup, so we&amp;rsquo;ll use that as the &lt;em&gt;base configuration&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For each model architecture and software/hardware configuration, I calculate the &lt;strong&gt;total training time relative to the base configuration instance training&lt;/strong&gt; for running the model training for the provided test script. In all cases, the P100 GPU &lt;em&gt;should&lt;/em&gt; perform better than the K80, and 32 vCPUs &lt;em&gt;should&lt;/em&gt; train faster than 16 vCPUs. The question is how &lt;em&gt;much&lt;/em&gt; faster?&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start using the &lt;a href=&#34;http://yann.lecun.com/exdb/mnist/&#34; target=&#34;_blank&#34;&gt;MNIST dataset&lt;/a&gt; of handwritten digits plus the common multilayer perceptron (MLP) architecture, with dense fully-connected layers. Lower training time is better.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/dl-cpu-gpu-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For this task, CNTK appears to be more effective than TensorFlow. Indeed, the P100 is faster than the K80 for the corresponding framework, although it&amp;rsquo;s not a dramatic difference. However, since the task is simple, the CPU performance is close to that of the GPU, which implies that the GPU is not as cost effective for a simple architecture.&lt;/p&gt;
&lt;p&gt;For each model architecture and configuration, I calculate a &lt;strong&gt;normalized training cost relative to the cost of the base configuration training&lt;/strong&gt;. Because GCE instance costs are prorated, we can simply calculate experiment cost by multiplying the total number of seconds the experiment runs by the cost of the instance (per second).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/dl-cpu-gpu-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Unsurprisingly, CPUs are more cost effective. However, the P100 is more cost &lt;em&gt;ineffective&lt;/em&gt; for this task than the K80.&lt;/p&gt;
&lt;p&gt;Now, let&amp;rsquo;s look at the same dataset with a convolutional neural network (CNN) approach for digit classification. Since CNNs are typically used for computer vision tasks, new graphic card architectures are optimized for CNN workflows, so it will be interesting to see how the P100 performs compared to the K80:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/dl-cpu-gpu-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/dl-cpu-gpu-8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Indeed, the P100 is twice as fast and the K80, but due to the huge cost premium, it&amp;rsquo;s not cost effective for this simple task. However, CPUs do not perform well on this task either, so notably the base configuration is the best configuration.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s go deeper with CNNs and look at the &lt;a href=&#34;https://www.cs.toronto.edu/%7Ekriz/cifar.html&#34; target=&#34;_blank&#34;&gt;CIFAR-10&lt;/a&gt; image classification dataset, and a model which utilizes a deep covnet + a multilayer perceptron and ideal for image classification (similar to the &lt;a href=&#34;https://gist.github.com/baraldilorenzo/07d7802847aaad0a35d3&#34; target=&#34;_blank&#34;&gt;VGG-16&lt;/a&gt; architecture).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/dl-cpu-gpu-9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/dl-cpu-gpu-10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Similar results to that of a normal MLP. Nothing fancy.&lt;/p&gt;
&lt;p&gt;The Bidirectional long-short-term memory (LSTM) architecture is great for working with text data like IMDb reviews. When I did &lt;a href=&#34;http://minimaxir.com/2017/06/keras-cntk/&#34; target=&#34;_blank&#34;&gt;my first benchmark article&lt;/a&gt;, I noticed that CNTK performed significantly better than TensorFlow, as &lt;a href=&#34;https://news.ycombinator.com/item?id=14538086&#34; target=&#34;_blank&#34;&gt;commenters on Hacker News&lt;/a&gt; noted that TensorFlow uses an inefficient implementation of the LSTM on the GPU.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/cntk-old.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;However, with Keras&amp;rsquo;s &lt;a href=&#34;https://keras.io/layers/recurrent/#cudnnlstm&#34; target=&#34;_blank&#34;&gt;new CuDNNRNN layers&lt;/a&gt; which leverage cuDNN, this inefficiency may be fixed, so for the K80/P100 TensorFlow GPU configs, I use a CuDNNLSTM layer instead of a normal LSTM layer. So let&amp;rsquo;s take another look:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/dl-cpu-gpu-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/dl-cpu-gpu-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;WOAH.&lt;/em&gt; TensorFlow is now more than &lt;em&gt;three times as fast&lt;/em&gt; than CNTK! (And compared against my previous benchmark, TensorFlow on the K80 w/ the CuDNNLSTM is about &lt;em&gt;7x as fast&lt;/em&gt; as it once was!) Even the CPU-only versions of TensorFlow are faster than CNTK on the GPU now, which implies significant improvements in the ecosystem outside of the CuDNNLSTM layer itself. (And as a result, CPUs are still more cost efficient)&lt;/p&gt;
&lt;p&gt;Lastly, LSTM text generation of &lt;a href=&#34;https://en.wikipedia.org/wiki/Friedrich_Nietzsche&#34; target=&#34;_blank&#34;&gt;Nietzsche&amp;rsquo;s&lt;/a&gt; &lt;a href=&#34;https://s3.amazonaws.com/text-datasets/nietzsche.txt&#34; target=&#34;_blank&#34;&gt;writings&lt;/a&gt; follows similar patterns to the other architectures, but without the drastic hit to the GPU.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/dl-cpu-gpu-11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/dl-cpu-gpu-12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The biggest surprise of these new benchmarks is that there is no configuration where the P100 is the most cost-effective option, even though the P100 is indeed faster than the K80 in all tests. Although per &lt;a href=&#34;https://developer.nvidia.com/cudnn&#34; target=&#34;_blank&#34;&gt;the cuDNN website&lt;/a&gt;, there is apparently only a 2x speed increase between the performance of the K80 and P100 using cuDNN 6, which is mostly consistent with the results of my benchmarks:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/benchmark-gpus/cudnn.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;I did not include a multi-GPU configuration in the benchmark data visualizations above using Keras&amp;rsquo;s new &lt;code&gt;multi_gpu_model&lt;/code&gt; &lt;a href=&#34;https://keras.io/utils/#multi_gpu_model&#34; target=&#34;_blank&#34;&gt;function&lt;/a&gt; because in my testing, the multi-GPU training &lt;em&gt;was equal to or worse than a single GPU&lt;/em&gt; in all tests.&lt;/p&gt;
&lt;p&gt;Taking these together, it&amp;rsquo;s possible that the overhead introduced by parallel, advanced architectures &lt;em&gt;eliminates the benefits&lt;/em&gt; for &amp;ldquo;normal&amp;rdquo; deep learning workloads which do not fully saturate the GPU. Rarely do people talk about diminishing returns in GPU performance with deep learning.&lt;/p&gt;
&lt;p&gt;In the future, I want to benchmark deep learning performance against more advanced deep learning use cases such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Reinforcement_learning&#34; target=&#34;_blank&#34;&gt;reinforcement learning&lt;/a&gt; and deep CNNs like &lt;a href=&#34;https://github.com/tensorflow/models/tree/master/research/inception&#34; target=&#34;_blank&#34;&gt;Inception&lt;/a&gt;. But that doesn&amp;rsquo;t mean these benchmarks are not relevant; as stated during the benchmark setup, the GPUs were tested against typical deep learning use cases, and now we see the tradeoffs that result.&lt;/p&gt;
&lt;p&gt;In all, with the price cuts on GPU instances, cost-performance is often &lt;em&gt;on par&lt;/em&gt; with preemptable CPU instances, which is an advantage if you want to train models faster and not risk the instance being killed unexpectedly. And there is still a lot of competition in this space: &lt;a href=&#34;https://www.amazon.com&#34; target=&#34;_blank&#34;&gt;Amazon&lt;/a&gt; offers a &lt;code&gt;p2.xlarge&lt;/code&gt; &lt;a href=&#34;https://aws.amazon.com/ec2/spot/&#34; target=&#34;_blank&#34;&gt;Spot Instance&lt;/a&gt; with a K80 GPU for $0.15-$0.20 an hour, less than half of the corresponding Google Compute Engine K80 GPU instance, although with &lt;a href=&#34;https://aws.amazon.com/ec2/spot/details/&#34; target=&#34;_blank&#34;&gt;a few bidding caveats&lt;/a&gt; which I haven&amp;rsquo;t fully explored yet. Competition will drive GPU prices down even further, and training deep learning models will become even easier.&lt;/p&gt;
&lt;p&gt;And as the cuDNN chart above shows, things will get &lt;em&gt;very&lt;/em&gt; interesting once Volta-based GPUs like the V100 are generally available and the deep learning frameworks support cuDNN 7 by default.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UPDATE &lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;17&lt;/sub&gt;&lt;/strong&gt;: &lt;em&gt;As pointed out by &lt;a href=&#34;https://news.ycombinator.com/item?id=15941682&#34; target=&#34;_blank&#34;&gt;dantiberian on Hacker News&lt;/a&gt;, Google Compute Engine now supports &lt;a href=&#34;https://cloud.google.com/compute/docs/instances/preemptible#preemptible_with_gpu&#34; target=&#34;_blank&#34;&gt;preemptible GPUs&lt;/a&gt;, which was apparently added after this post went live. Preemptable GPUs are exactly half the price of normal GPUs (for both K80s and P100s; $0.73/hr and $0.22/hr respectively), so they&amp;rsquo;re about double the cost efficiency (when factoring in the cost of the base preemptable instance), which would put them squarely ahead of CPUs in all cases. (and since the CPU instances used here were also preemptable, it&amp;rsquo;s apples-to-apples)&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;All scripts for running the benchmark are available in &lt;a href=&#34;https://github.com/minimaxir/keras-cntk-benchmark/tree/master/v2&#34; target=&#34;_blank&#34;&gt;this GitHub repo&lt;/a&gt;. You can view the R/ggplot2 code used to process the logs and create the visualizations in &lt;a href=&#34;http://minimaxir.com/notebooks/benchmark-gpus/&#34; target=&#34;_blank&#34;&gt;this R Notebook&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>